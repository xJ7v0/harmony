#!/bin/bash
# Description: An easy to use firewall builder for computers using dual nics or just one
# Dependencies: iptables, arptables (optional)

# Change this if needed to be if planning on using dnscrypt-proxy in your setup
DNSCRYPT_RESOLVERS="/usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv"

OPT="${1}"

#if [ ! -z ${DNS_FILE} ]; then
#	DNS_FILE="/root/.config/harmony/dns"
#fi

# Some routines to help speed up loading config files
# Since these are static we dont need to load the rules every time, just once
INIT() {

	### To do any kind of 'url'/'host' filtering you must have a working dns ###
	if [[ -f ${DNSCRYPT_RESOLVERS} && $(which dnscrypt-proxy 2>/dev/null) && ! $(iptables -nL "OUT_DNSCRYPT_ACL" 2>/dev/null) ]]; then
		iptables -N IN_DNSCRYPT_ACL
		iptables -N OUT_DNSCRYPT_ACL

		IFACE=$(netstat -rnf iface 2>&1 |  sed -e "s/[[:space:]]\+/ /g" | grep UG | cut -d " " -f8)
		IFACE_IP="$(ip address show ${IFACE} | grep -oP '(?<=inet ).*(?=/)')"

		for dns_host in $(egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' ${DNSCRYPT_RESOLVERS} | cut -d "," -f1); do

			if [[ ${dns_host} == *:* ]]; then
				HOST_IP=$(echo "${dns_host}" | cut -d ":" -f1)
				HOST_PORT=$(echo "${dns_host}" | cut -d ":" -f2)
			else
				HOST_IP="${dns_host}"
				HOST_PORT=443
			fi
			# TCP
			iptables -A OUT_DNSCRYPT_ACL -o ${IFACE} -p tcp --dport ${HOST_PORT} -s ${IFACE_IP} -d ${HOST_IP} -m owner --uid-owner dnscrypt -m owner --gid-owner dnscrypt -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A IN_DNSCRYPT_ACL -i ${IFACE} -p tcp --sport ${HOST_PORT} -d ${IFACE_IP} -s ${HOST_IP} -m state --state ESTABLISHED -j ACCEPT
			# UDP
			iptables -A OUT_DNSCRYPT_ACL -o ${IFACE} -p udp --dport ${HOST_PORT} -s ${IFACE_IP} -d ${HOST_IP} -m owner --uid-owner dnscrypt -m owner --gid-owner dnscrypt -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A IN_DNSCRYPT_ACL -i ${IFACE} -p udp --sport ${HOST_PORT} -d ${IFACE_IP} -s ${HOST_IP} -m state --state ESTABLISHED -j ACCEPT

		done
	fi
}

FLUSH() {
	TYPE="${1}"
	for type in ${TYPE}; do


		if [[ ${type} == "DEFAULT" ]]; then

			iptables -F
			iptables -X
			iptables -t filter -F
			iptables -t filter -X
			iptables -t mangle -F
			iptables -t mangle -X
			iptables -t nat -F
			iptables -t nat -X
			iptables -t raw -F
			iptables -t raw -X

			if [ $(which arptables 2>/dev/null) ]; then
				arptables -F
				arptables -X
				arptables -t nat -F
				arptables -t nat -X
				arptables -t mangle -F
				arptables -t mangle -X

				arptables -P INPUT DROP
				arptables -P OUTPUT DROP
				arptables -P FORWARD DROP
			fi
		fi

		if [[ ${type} == "LOG" ]]; then

			for chain in $(iptables -nvL | grep -ai chain | cut -d " " -f2 | grep -ai log); do
				iptables -F "${chain}"
				iptables -X "${chain}"

			done
		fi


#		if [[ ${type} == "ALL" ]]; then
#
#			iptables-restore < <(printf "%s\n%s\n%s\n" "-P INPUT DROP" "-P FORWARD DROP" "-P OUTPUT DROP")
#
#		fi


	done

	# Default Policies
	iptables -P INPUT DROP
	iptables -P OUTPUT DROP
	iptables -P FORWARD DROP

	INIT

	iptables -A OUTPUT -j OUT_DNSCRYPT_ACL
	iptables -A INPUT -j IN_DNSCRYPT_ACL


#	if [ ! -f ${DNS_FILE} ];


}

PORT_KNOCKING() {
	COMBO="${1}"
	DST_PORT="${2}"

	if [[ ! $(iptables -nL "KNOCKING_${DST_PORT}" 2>/dev/null) ]]; then
		iptables -N "KNOCKING_${DST_PORT}"
	fi
}

PREROUTING_SECURTIY() {

	# https://javapipe.com/iptables-ddos-protection
	### 1: Drop invalid packets ###
	/sbin/iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP

	### 2: Drop TCP packets that are new and are not SYN ###
	/sbin/iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP

	### 3: Drop SYN packets with suspicious MSS value ###
	/sbin/iptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP

	### 4: Block packets with bogus TCP flags ###
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP

	### 5: Block spoofed packets ###
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 224.0.0.0/3 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 169.254.0.0/16 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 172.16.0.0/12 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 192.0.2.0/24 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 192.168.0.0/16 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 10.0.0.0/8 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 0.0.0.0/8 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 240.0.0.0/5 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 127.0.0.0/8 -j DROP

	### 6: Drop ICMP (you usually don't need this protocol) ###
	/sbin/iptables -t mangle -A PREROUTING -p icmp -j DROP

	### 7: Drop fragments in all chains ###
	/sbin/iptables -t mangle -A PREROUTING -f -j DROP

	### 8: Limit connections per source IP ###
	/sbin/iptables -A INPUT -p tcp -m connlimit --connlimit-above 111 -j REJECT --reject-with tcp-reset

	### 9: Limit RST packets ###
	/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT
	/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP

	### 10: Limit new TCP connections per second per source IP ###
	/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m limit --limit 60/s --limit-burst 20 -j ACCEPT
	/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -j DROP

	### 11: Use SYNPROXY on all ports (disables connection limiting rule) ###
	#/sbin/iptables -t raw -A PREROUTING -p tcp -m tcp --syn -j CT --notrack
	#/sbin/iptables -A INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460
	#/sbin/iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

	### Protection against port scanning ###
	if [[ ! $(iptables -nL "port-scanning" 2>/dev/null) ]]; then
		/sbin/iptables -N port-scanning
		/sbin/iptables -A port-scanning -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s --limit-burst 2 -j RETURN
		/sbin/iptables -A port-scanning -j DROP
	fi
}

# Use only if diagnosing connection issues on the loopback interface!
DEFAULT_LO() {
	iptables -A INPUT -i lo -j ACCEPT
	iptables -A OUTPUT -o lo -j ACCEPT
}


#ACL_DNS() {
#	if [ ! -d $(dirname "${DNS_FILE}") ]; then
#		mkdir -p $(dirname "${DNS_FILE}"
#}

# This allows connections to servers from any interface
INPUT() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	PROTOCOL="${4}"
	IFS=' 	
'
	if [ ! -z ${5} ]; then
		MAC="-m mac --mac-source ${5}"
	fi

	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			INPUT_IFACE=$(echo ${IP} | cut -d ":" -f1)
			INPUT_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			INPUT_IFACE=${interface}
			INPUT_IP=${IP}
		fi

		if [[ ${interface} =~ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} ]]; then
			IFACE_IP=${interface}
			interface=${INPUT_IFACE}
		else
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
		fi

		if [[ ${INPUT_IFACE} == ${interface} ]]; then

			iptables -A INPUT -i ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${INPUT_IP} -d ${IFACE_IP} ${MAC} -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${INPUT_IP} -s ${IFACE_IP} -m state --state ESTABLISHED -j ACCEPT
		fi
	done
}

# This allows the router to connect to other servers from any interface
OUTPUT() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	PROTOCOL="${4}"
	IFS=' 	
'
	if [ ! -z ${5} ]; then
		MAC="-m mac --mac-source ${5}"
	fi

	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			OUTPUT_IFACE=$(echo ${IP} | cut -d ":" -f1)
			OUTPUT_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			OUTPUT_IFACE=${interface}
			OUTPUT_IP=${IP}
		fi


		if [[ ${interface} =~ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} ]]; then
			IFACE_IP=${interface}
			interface=${OUTPUT_IFACE}
		else
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
		fi


		if [[ ${OUTPUT_IFACE} == ${interface} ]]; then

			iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -s ${LAN_IP} -d ${IFACE_IP} ${MAC} -m state --state ESTABLISHED -j ACCEPT
			iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -d ${LAN_IP} -s ${IFACE_IP} -m state --state NEW,ESTABLISHED -j ACCEPT

		fi
	done
}

# This allows lan clients to use the internet
FORWARD_NAT() {
	SRC_IFACE="${1}"
	SRC_IP="${2}"
	DST_IFACE="${3}"
	DST_IP="${4}"
	DST_PORT="${5}"
	PROTOCOL="${6}"
	IFS=' 	
'
	for interface in ${SRC_IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${SRC_IP} == *':'* ]]; then
			SRC_IFACE_1=$(echo ${SRC_IP} | cut -d ":" -f1)
			SRC_IP_1=$(echo ${SRC_IP} | cut -d ":" -f2)
		else
			SRC_IFACE_1=${interface}
			SRC_IP_1=${SRC_IP}
		fi

		if [[ ${SRC_IFACE_1} == ${interface} ]]; then
			iptables -A FORWARD -i ${interface} -p ${PROTOCOL} --dport ${DST_PORT} -s ${SRC_IP_1} -d ${DST_IP} -j ACCEPT
			iptables -A FORWARD -i ${DST_IFACE} -p ${PROTOCOL} --sport ${DST_PORT} -d ${SRC_IP_1} -s ${DST_IP} -j ACCEPT
			iptables -t nat -A POSTROUTING -o ${DST_IFACE} -j MASQUERADE
		fi
	done
}

# This allows which user and group can connect to what service
ACL_SERVICES() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	USER_GROUP="${4}"
	PROTOCOL="${5}"
	IFS=' 	
'
	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			ACL_IFACE=$(echo ${IP} | cut -d ':' -f1)
			ACL_IP=$(echo ${IP} | cut -d ':' -f2)
		else
			ACL_IFACE=${interface}
			ACL_IP=${IP}
		fi

		if [[ ${ACL_IFACE} == ${interface} ]]; then

			if [[ ${interface} == *':'* ]]; then
				interface=$(echo "${interface}" | cut -d ':' -f1)
				IFACE_IP=$(echo "${ACL_IFACE}" | cut -d ':' -f2)
			else
				IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
			fi

			USER=$(echo ${USER_GROUP} | cut -zd ':' -f1)
			GROUP=$(echo ${USER_GROUP} | cut -zd ':' -f2)

			if [ ! -z ${USER} ]; then
				USER="-m owner --uid-owner ${USER}"
			fi

			if [ ! -z ${GROUP} ]; then
				GROUP="-m owner --gid-owner ${GROUP}"
			fi

			iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${IFACE_IP} -d ${ACL_IP} ${USER} ${GROUP} -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${IFACE_IP} -s ${ACL_IP} -m state --state ESTABLISHED -j ACCEPT
		fi
	done
}

### LO NOTES
### First a connection leaves // client:**** -> server:80			ACL_LO_CLIENT()
### Then a connection is received // server:80 <- client:****			ACL_LO_SERVER()
### Next server tries to connect back // server:80 -> client:****		ACL_LO_SERVER()
### Finally client establishes the connection // client:**** <- server:80	ACL_LO_CLIENT()


# For the time being, we need a special function for ACL'ing loopback
ACL_LO_CLIENT() {

	IP="${1}"
	PORT="${2}"
	USER_GROUP="${3}"
	PROTOCOL="${4}"
	IFS=' 	
'

	USER=$(echo ${USER_GROUP} | cut -zd ':' -f1)
	GROUP=$(echo ${USER_GROUP} | cut -zd ':' -f2)

	if [ ! -z ${USER} ]; then
		USER="-m owner --uid-owner ${USER}"
	fi

	if [ ! -z ${GROUP} ]; then
		GROUP="-m owner --gid-owner ${GROUP}"
	fi

	iptables -A OUTPUT -o lo -p ${PROTOCOL} -s ${IP} -d ${IP} --dport ${PORT} ${USER} ${GROUP} -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT -i lo -p ${PROTOCOL} -d ${IP} -s ${IP} --sport ${PORT} -m state --state ESTABLISHED -j ACCEPT
}

# A server function to prevent reduntant rules
ACL_LO_SERVER() {

	IP="${1}"
	PORT="${2}"
	USER_GROUP="${3}"
	PROTOCOL="${4}"
	IFS=' 	
'

	USER=$(echo ${USER_GROUP} | cut -zd ':' -f1)
	GROUP=$(echo ${USER_GROUP} | cut -zd ':' -f2)

	if [ ! -z ${USER} ]; then
		USER="-m owner --uid-owner ${USER}"
	fi

	if [ ! -z ${GROUP} ]; then
		GROUP="-m owner --gid-owner ${GROUP}"
	fi

	iptables -A INPUT -i lo -p ${PROTOCOL} -d ${IP} -s ${IP} --dport ${PORT} -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A OUTPUT -o lo -p ${PROTOCOL} -s ${IP} -d ${IP} --sport ${PORT} ${USER} ${GROUP} -m state --state ESTABLISHED -j ACCEPT
}

LOG(){

	if [[ ${LOGGING_PREROUTING} != 0 && ${LOGGING_PREROUTING} -le 7 ]]; then
		iptables -N LOGGING_PREROUTING
		iptables -t nat -A PREROUTING -j LOGGING_PREROUTING
		iptables -t nat -A PREROUTING -j LOG
		iptables -t nat -A PREROUTING -j LOG --log-prefix "IPTABLES-Dropped_PREROUTING: " --log-level ${LOGGING_PREROUTING}
		iptables -A LOGGING_PREROUTING -j DROP
	fi

	if [[ ${LOGGING_LAN} != 0 && ${LOGGING_LAN} -le 7 ]]; then
		iptables -N LOGGING_LAN
		iptables -A INPUT -i ${LAN} -j LOGGING_LAN
		iptables -A LOGGING_LAN -j LOG --log-prefix "IPTABLES-Dropped_LAN: " --log-level ${LOGGING_LAN}
		iptables -A LOGGING_LAN -j DROP
		iptables -A OUTPUT -o ${LAN} -j LOGGING_LAN
		iptables -A LOGGING_LAN -j LOG --log-prefix "IPTABLES-Dropped_LAN: " --log-level ${LOGGING_LAN}
		iptables -A LOGGING_LAN -j DROP
	fi

	if [[ ${LOGGING_WAN} != 0 && ${LOGGING_WAN} -le 7 ]]; then
		iptables -N LOGGING_WAN
		iptables -A INPUT -i ${WAN} -j LOGGING_WAN
		iptables -A LOGGING_WAN -j LOG --log-prefix "IPTABLES-Dropped_WAN: " --log-level ${LOGGING_WAN}
		iptables -A LOGGING_WAN -j DROP
		iptables -A OUTPUT -o ${WAN} -j LOGGING_WAN
		iptables -A LOGGING_WAN -j LOG --log-prefix "IPTABLES-Dropped_WAN: " --log-level ${LOGGING_WAN}
		iptables -A LOGGING_WAN -j DROP
	fi

	if [[ ${LOGGING_FORWARD} != 0 && ${LOGGING_FORWARD} -le 7 ]]; then
		iptables -N LOGGING_FORWARD
		iptables -A FORWARD -j LOGGING_FORWARD
		iptables -A LOGGING_FORWARD -j LOG --log-prefix "IPTABLES-Dropped_FORWARD: " --log-level ${LOGGING_FORWARD}
		iptables -A LOGGING_FORWARD -j DROP
        fi

	if [[ ${LOGGING_POSTROUTING} != 0 && ${LOGGING_POSTROUTING} -le 7 ]]; then
		iptables -N LOGGING_POSTROUTING
		iptables -t nat -A POSTROUTING -j LOGGING_POSTROUTING
		iptables -t nat -A POSTROUTING -j LOG
		iptables -t nat -A POSTROUTING -j LOG --log-prefix "IPTABLES-Dropped_POSTROUTING: " --log-level ${LOGGING_POSTROUTING}
		iptables -A LOGGING_POSTROUTING -j DROP
        fi
}

SAVE() {
	service iptables restart
}

USAGE() {

	echo """
$(basename $0): - iptables wrapper for restrictive setups
	Usage: $(basename $0)  file...
	Usage: $(basename $0)  OPTION
OPTIONS
	-f	properly flush everything in iptables and set the deafult policy to drop

	-h	print this help message

	-u	update resolved hostnames

FUNCTIONS
$(for fun in $(declare -F | cut -d ' ' -f3);do echo -e '\t'${fun}'  '$(declare -f ${fun} | grep \=\"\$\{.*\}) |\
sed 's/\s\s\+/:/g;s/\([a-z)]\)\s\([(0-9A]\)/\1:\2/g';done | column -s: -t)

ARGUMENTS TO FUNCTIONS
	IFACE: interface, eth0, eth1, etc.


"""

	exit 1

}

case ${OPT} in

	"-f") FLUSH; exit 0;;
	"-h") USAGE;;
	"-u") UPDATE_DNS;;
	*.conf) . "${1}";;

esac
