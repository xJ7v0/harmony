#!/bin/bash
# Description: An easy to use firewall builder for computers using dual nics or just one
# Dependencies: iptables, arptables (optional)

# Change this if needed to be
DNSCRYPT_RESOLVERS="/usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv"

OPT="${1}"

#if [ ! -z ${DNS_FILE} ]; then
#	DNS_FILE="/root/.config/harmony/dns"
#fi

# Some routines to help speed up loading config files
# Since these are static we dont need to load the rules every time, just once
INIT() {

	### To do any kind of 'url'/'host' filtering you must have a working dns ###
	if [[ -f ${DNSCRYPT_RESOLVERS} && $(which dnscrypt-proxy 2>/dev/null) && ! $(iptables -n --list "OUT_DNSCRYPT_ACL" 2>/dev/null) ]]; then
		iptables -N IN_DNSCRYPT_ACL
		iptables -N OUT_DNSCRYPT_ACL

		IFACE=$(netstat -rnf iface 2>&1 |  sed -e "s/[[:space:]]\+/ /g" | grep UG | cut -d " " -f8)
		IFACE_IP="$(ip address show ${IFACE} | grep -oP '(?<=inet ).*(?=/)')"

		for dns_host in $(egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' ${DNSCRYPT_RESOLVERS} | cut -d "," -f1); do

 			if [[ ${dns_host} == *:* ]]; then
				HOST_IP=$(echo ${dns_host} | cut -d ":" -f1)
				HOST_PORT=$(echo ${dns_host} | cut -d ":" -f2)
			else
				HOST_IP=${dns_host}
				HOST_PORT=443
			fi
			# TCP
			iptables -A OUT_DNSCRYPT_ACL -o ${IFACE} -p tcp --dport ${HOST_PORT} -s ${IFACE_IP} -d ${HOST_IP} -m owner --uid-owner dnscrypt -m owner --gid-owner dnscrypt -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A IN_DNSCRYPT_ACL -i ${IFACE} -p tcp --sport ${HOST_PORT} -d ${IFACE_IP} -s ${HOST_IP} -m state --state ESTABLISHED -j ACCEPT
			# UDP
			iptables -A OUT_DNSCRYPT_ACL -o ${IFACE} -p udp --dport ${HOST_PORT} -s ${IFACE_IP} -d ${HOST_IP} -m owner --uid-owner dnscrypt -m owner --gid-owner dnscrypt -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A IN_DNSCRYPT_ACL -i ${IFACE} -p udp --sport ${HOST_PORT} -d ${IFACE_IP} -s ${HOST_IP} -m state --state ESTABLISHED -j ACCEPT

		done
	fi


}

FLUSH() {
	#iptables -F
	#iptables -X
	iptables -t nat -F
	iptables -t nat -X
	iptables -t mangle -F
	iptables -t mangle -X

	iptables -F INPUT
	iptables -F OUTPUT
	iptables -F FORWARD

	iptables -P INPUT DROP
	iptables -P OUTPUT DROP
	iptables -P FORWARD DROP

	if [ $(which arptables 2>/dev/null) ]; then
		arptables -F
		arptables -X
		arptables -t nat -F
		arptables -t nat -X
		arptables -t mangle -F
		arptables -t mangle -X

		arptables -P INPUT DROP
		arptables -P OUTPUT DROP
		arptables -P FORWARD DROP
	fi

	iptables -A OUTPUT -j OUT_DNSCRYPT_ACL
	iptables -A INPUT -j IN_DNSCRYPT_ACL


#	if [ ! -f ${DNS_FILE} ];


}

PREROUTING_SECURTIY() {

	# https://javapipe.com/iptables-ddos-protection
	### 1: Drop invalid packets ###
	/sbin/iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP

	### 2: Drop TCP packets that are new and are not SYN ###
	/sbin/iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP

	### 3: Drop SYN packets with suspicious MSS value ###
	/sbin/iptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP

	### 4: Block packets with bogus TCP flags ###
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP
	/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP

	### 5: Block spoofed packets ###
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 224.0.0.0/3 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 169.254.0.0/16 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 172.16.0.0/12 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 192.0.2.0/24 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 192.168.0.0/16 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 10.0.0.0/8 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 0.0.0.0/8 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 240.0.0.0/5 -j DROP
	/sbin/iptables -t mangle -A PREROUTING -i ${WAN} -s 127.0.0.0/8 -j DROP

	### 6: Drop ICMP (you usually don't need this protocol) ###
	/sbin/iptables -t mangle -A PREROUTING -p icmp -j DROP

	### 7: Drop fragments in all chains ###
	/sbin/iptables -t mangle -A PREROUTING -f -j DROP

	### 8: Limit connections per source IP ###
	/sbin/iptables -A INPUT -p tcp -m connlimit --connlimit-above 111 -j REJECT --reject-with tcp-reset

	### 9: Limit RST packets ###
	/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT
	/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP

	### 10: Limit new TCP connections per second per source IP ###
	/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m limit --limit 60/s --limit-burst 20 -j ACCEPT
	/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -j DROP

	### 11: Use SYNPROXY on all ports (disables connection limiting rule) ###
	#/sbin/iptables -t raw -A PREROUTING -p tcp -m tcp --syn -j CT --notrack
	#/sbin/iptables -A INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460
	#/sbin/iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

	### Protection against port scanning ###
	if [ ! $(iptables -n --list "port-scanning" 2>/dev/null) ]; then
		/sbin/iptables -N port-scanning
		/sbin/iptables -A port-scanning -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s --limit-burst 2 -j RETURN
		/sbin/iptables -A port-scanning -j DROP
	fi
}

# To be changed
DEFAULT_LO() {
	iptables -A INPUT -i lo -j ACCEPT
	iptables -A OUTPUT -o lo -j ACCEPT
}

#ACL_LO() {


#}

#ACL_DNS() {
#	if [ ! -d $(dirname "${DNS_FILE}") ]; then
#		mkdir -p $(dirname "${DNS_FILE}"
#}

# This allows connections to servers from any interface
INPUT() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	PROTOCOL="${4}"
	IFS=' 	
'
	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			INPUT_IFACE=$(echo ${IP} | cut -d ":" -f1)
			INPUT_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			INPUT_IFACE=${interface}
			INPUT_IP=${IP}
		fi

		if [[ ${INPUT_IFACE} == ${interface} ]]; then
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
			if [ ! -z ${5} ]; then
				MAC="${5}"
				iptables -A INPUT -i ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${INPUT_IP} -d ${IFACE_IP} -m mac --mac-source ${MAC} -m state --state NEW,ESTABLISHED -j ACCEPT
				iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${INPUT_IP} -s ${IFACE_IP} -m state --state ESTABLISHED -j ACCEPT
			else
				iptables -A INPUT -i ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${INPUT_IP} -d ${IFACE_IP} -m state --state NEW,ESTABLISHED -j ACCEPT
				iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${INPUT_IP} -s ${IFACE_IP} -m state --state ESTABLISHED -j ACCEPT
			fi
		fi
	done
}

# This allows the router to connect to other servers from any interface
OUTPUT() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	PROTOCOL="${4}"
	IFS=' 	
'
	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			OUTPUT_IFACE=$(echo ${IP} | cut -d ":" -f1)
			OUTPUT_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			OUTPUT_IFACE=${interface}
			OUTPUT_IP=${IP}
		fi

		if [[ ${OUTPUT_IFACE} == ${interface} ]]; then
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
			if [ ! -z ${5} ]; then
				MAC="${5}"
				iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -s ${LAN_IP} -d ${IFACE_IP} -m mac --mac-source ${MAC} -m state --state ESTABLISHED -j ACCEPT
				iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -d ${LAN_IP} -s ${IFACE_IP} -m state --state NEW,ESTABLISHED -j ACCEPT
			else
				iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -s ${LAN_IP} -d ${IFACE_IP} -m state --state ESTABLISHED -j ACCEPT
				iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -d ${LAN_IP} -s ${IFACE_IP} -m state --state NEW,ESTABLISHED -j ACCEPT
			fi

		fi
	done
}


# This allows lan clients to use the internet
FORWARD_NAT() {
	NAT_IFACE_1="${1}"
	NAT_IFACE_2="${2}"
        IP="${3}"
	PORT="${4}"
	PROTOCOL="${5}"
	IFS=' 	
'
	for interface in ${NAT_IFACE_1}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			FORWARD_IFACE_1=$(echo ${IP} | cut -d ":" -f1)
			FORWARD_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			FORWARD_IFACE=${interface}
			FORWARD_IP=${IP}
		fi

		if [[ ${FORWARD_IFACE} == ${interface} ]]; then
			iptables -A FORWARD -i ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${FORWARD_IP} -j ACCEPT
			iptables -A FORWARD -i ${NAT_IFACE_2} -p ${PROTOCOL} --sport ${PORT} -d ${FORWARD_IP} -j ACCEPT
			iptables -t nat -A POSTROUTING -o ${NAT_IFACE_2} -j MASQUERADE

		fi
	done
}

# This allows which user and group on the router can connect to what service
ACL_SERVICES() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	USER="${4}"
	GROUP="${5}"
	PROTOCOL="${6}"
	IFS=' 	
'
	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			ACL_IFACE=$(echo ${IP} | cut -d ":" -f1)
			ACL_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			ACL_IFACE=${interface}
			ACL_IP=${IP}
		fi

		if [[ ${ACL_IFACE} == ${interface} ]]; then
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
			iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${IFACE_IP} -d ${ACL_IP} -m owner --uid-owner ${USER} -m owner --gid-owner ${GROUP} -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${IFACE_IP} -s ${ACL_IP} -m state --state ESTABLISHED -j ACCEPT
		fi
	done
}

# This allows which group on the router can connect to what service
ACL_SERVICES_GROUP() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	GROUP="${4}"
	PROTOCOL="${5}"
	IFS=' 	
'
	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			ACL_GROUP_IFACE=$(echo ${IP} | cut -d ":" -f1)
			ACL_GROUP_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			ACL_GROUP_IFACE=${interface}
			ACL_GROUP_IP=${IP}
		fi

		if [[ ${ACL_GROUP_IFACE} == ${interface} ]]; then
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
			iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${IFACE_IP} -d ${ACL_GROUP_IP} -m owner --gid-owner ${GROUP} -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${IFACE_IP} -s ${ACL_GROUP_IP} -m state --state ESTABLISHED -j ACCEPT
		fi
	done
}

# This allows which user on the router can connect to what service
ACL_SERVICES_USER() {
	IFACE="${1}"
	IP="${2}"
	PORT="${3}"
	USER="${4}"
	PROTOCOL="${5}"
	IFS=' 	
'
	for interface in ${IFACE}; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ ${IP} == *':'* ]]; then
			ACL_USER_IFACE=$(echo ${IP} | cut -d ":" -f1)
			ACL_USER_IP=$(echo ${IP} | cut -d ":" -f2)
		else
			ACL_USER_IFACE=${interface}
			ACL_USER_IP=${IP}
		fi

		if [[ ${ACL_USER_IFACE} == ${interface} ]]; then
			IFACE_IP="$(ip address show ${interface} | grep -oP '(?<=inet ).*(?=/)')"
			iptables -A OUTPUT -o ${interface} -p ${PROTOCOL} --dport ${PORT} -s ${IFACE_IP} -d ${ACL_USER_IP} -m owner --uid-owner ${USER} -m state --state NEW,ESTABLISHED -j ACCEPT
			iptables -A INPUT -i ${interface} -p ${PROTOCOL} --sport ${PORT} -d ${IFACE_IP} -s ${ACL_USER_IP} -m state --state ESTABLISHED -j ACCEPT
		fi
	done
}

LOG(){

	if [[ ${LOGGING_PREROUTING} != 0 && ${LOGGING_PREROUTING} -le 7 ]]; then
		iptables -N LOGGING_PREROUTING
		iptables -t nat -A PREROUTING -j LOGGING_PREROUTING
		iptables -t nat -A PREROUTING -j LOG
		iptables -t nat -A PREROUTING -j LOG --log-prefix "IPTABLES-Dropped_PREROUTING: " --log-level ${LOGGING_PREROUTING}
		iptables -A LOGGING_PREROUTING -j DROP
	fi

	if [[ ${LOGGING_LAN} != 0 && ${LOGGING_LAN} -le 7 ]]; then
		iptables -N LOGGING_LAN
		iptables -A INPUT -i ${LAN} -j LOGGING_LAN
		iptables -A LOGGING_LAN -j LOG --log-prefix "IPTABLES-Dropped_LAN: " --log-level ${LOGGING_LAN}
		iptables -A LOGGING_LAN -j DROP
		iptables -A OUTPUT -o ${LAN} -j LOGGING_LAN
		iptables -A LOGGING_LAN -j LOG --log-prefix "IPTABLES-Dropped_LAN: " --log-level ${LOGGING_LAN}
		iptables -A LOGGING_LAN -j DROP
	fi

	if [[ ${LOGGING_WAN} != 0 && ${LOGGING_WAN} -le 7 ]]; then
		iptables -N LOGGING_WAN
		iptables -A INPUT -i ${WAN} -j LOGGING_WAN
		iptables -A LOGGING_WAN -j LOG --log-prefix "IPTABLES-Dropped_WAN: " --log-level ${LOGGING_WAN}
		iptables -A LOGGING_WAN -j DROP
		iptables -A OUTPUT -o ${WAN} -j LOGGING_WAN
		iptables -A LOGGING_WAN -j LOG --log-prefix "IPTABLES-Dropped_WAN: " --log-level ${LOGGING_WAN}
		iptables -A LOGGING_WAN -j DROP
	fi

	if [[ ${LOGGING_FORWARD} != 0 && ${LOGGING_FORWARD} -le 7 ]]; then
		iptables -N LOGGING_FORWARD
		iptables -A FORWARD -j LOGGING_FORWARD
		iptables -A LOGGING_FORWARD -j LOG --log-prefix "IPTABLES-Dropped_FORWARD: " --log-level ${LOGGING_FORWARD}
		iptables -A LOGGING_FORWARD -j DROP
        fi

	if [[ ${LOGGING_POSTROUTING} != 0 && ${LOGGING_POSTROUTING} -le 7 ]]; then
		iptables -N LOGGING_POSTROUTING
		iptables -t nat -A POSTROUTING -j LOGGING_POSTROUTING
		iptables -t nat -A POSTROUTING -j LOG
		iptables -t nat -A POSTROUTING -j LOG --log-prefix "IPTABLES-Dropped_POSTROUTING: " --log-level ${LOGGING_POSTROUTING}
		iptables -A LOGGING_POSTROUTING -j DROP
        fi
}

SAVE() {
	service iptables restart
}

USAGE() {

	echo """
$(basename $0): - iptables wrapper for restrictive setups
	Usage: $(basename $0)  file...
	Usage: $(basename $0)  OPTION
OPTIONS
	-f	properly flush everything in iptables and set the deafult policy to drop

	-h	print this help message

	-u	update resolved hostnames

FUNCTIONS
$(for fun in $(declare -F | cut -d ' ' -f3);do echo -e '\t'${fun}'  '$(declare -f ${fun} | grep \=\"\$\{.*\}) |\
sed 's/\s\s\+/:/g;s/\([a-z)]\)\s\([(0-9A]\)/\1:\2/g';done | column -s: -t)

ARGUMENTS TO FUNCTIONS
	IFACE: interface, eth0, eth1, etc.


"""

	exit 1

}

INIT

case ${OPT} in

	"-f") FLUSH; exit 0;;
	"-h") USAGE;;
	"-u") UPDATE_DNS;;
	*.conf) . "${1}";;

esac
