#!/bin/bash
# Description: plugin for iptables
# Dependencies: iptables, arptables (optional)

local OPT="$1"

FLUSH()
{
	local TYPE="$1"
	for type in $TYPE; do

		if [[ $type == "DEFAULT" ]]; then

			iptables -F
			iptables -X
			iptables -t filter -F
			iptables -t filter -X
			iptables -t mangle -F
			iptables -t mangle -X
			iptables -t nat -F
			iptables -t nat -X
			iptables -t raw -F
			iptables -t raw -X

			if [ $(which arptables 2>/dev/null) ]; then
				arptables -F
				arptables -X
				arptables -t nat -F
				arptables -t nat -X
				arptables -t mangle -F
				arptables -t mangle -X

				arptables -P INPUT DROP
				arptables -P OUTPUT DROP
				arptables -P FORWARD DROP
			fi
		fi

		if [[ $type == "LOG" ]]; then

			for chain in $(iptables -nvL | grep -ai chain | cut -d " " -f2 | grep -ai log); do
				iptables -F "$chain"
				iptables -X "$chain"

			done
		fi
	done

	# Default Policies
	iptables -P INPUT DROP
	iptables -P OUTPUT DROP
	iptables -P FORWARD DROP

	#iptables -A OUTPUT -j OUT_DNSCRYPT_ACL
	#iptables -A INPUT -j IN_DNSCRYPT_ACL
}

PREROUTING_SECURTIY()
{
	local WAN="$1"

	# https://javapipe.com/iptables-ddos-protection
	### 1: Drop invalid packets ###
	iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP

	### 2: Drop TCP packets that are new and are not SYN ###
	iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP

	### 3: Drop SYN packets with suspicious MSS value ###
	iptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP

	### 4: Block packets with bogus TCP flags ###
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP
	iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP

	### 5: Block spoofed packets ###
	if [[ ! -z $WAN ]]; then
		iptables -t mangle -A PREROUTING -i $WAN -s 224.0.0.0/3 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 169.254.0.0/16 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 172.16.0.0/12 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 192.0.2.0/24 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 192.168.0.0/16 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 10.0.0.0/8 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 0.0.0.0/8 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 240.0.0.0/5 -j DROP
		iptables -t mangle -A PREROUTING -i $WAN -s 127.0.0.0/8 -j DROP
	fi
	### 6: Drop ICMP (you usually don't need this protocol) ###
	iptables -t mangle -A PREROUTING -p icmp -j DROP

	### 7: Drop fragments in all chains ###
	iptables -t mangle -A PREROUTING -f -j DROP

	### 8: Limit connections per source IP ###
	iptables -A INPUT -p tcp -m connlimit --connlimit-above 111 -j REJECT --reject-with tcp-reset

	### 9: Limit RST packets ###
	iptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT
	iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP

	### 10: Limit new TCP connections per second per source IP ###
	iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m limit --limit 60/s --limit-burst 20 -j ACCEPT
	iptables -A INPUT -p tcp -m conntrack --ctstate NEW -j DROP

	### 11: Use SYNPROXY on all ports (disables connection limiting rule) ###
	#iptables -t raw -A PREROUTING -p tcp -m tcp --syn -j CT --notrack
	#iptables -A INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460
	#iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

	### Protection against port scanning ###
	if [[ ! $(iptables -nL "port-scanning" 2>/dev/null) ]]; then
		iptables -N port-scanning
		iptables -A port-scanning -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s --limit-burst 2 -j RETURN
		iptables -A port-scanning -j DROP
	fi

	#iptables -A OUTPUT -m tcp -p tcp --tcp-flags ALL ACK -j ACCEPT
}


PORT_KNOCKING()
{
	local COMBO="$1"
	local DST_PORT=$2

	if [[ ! $(iptables -nL "KNOCKING_${DST_PORT}" 2>/dev/null) ]]; then
		iptables -N "KNOCKING_${DST_PORT}"
	fi
}

# Use only if diagnosing connection issues on the loopback interface!
DEFAULT_LO()
{
	iptables -A INPUT  -i lo -s 127.0.0.1/8 -d 127.0.0.1/8 -j ACCEPT
	iptables -A OUTPUT -o lo -d 127.0.0.1/8 -s 127.0.0.1/8 -j ACCEPT
}

#ACL_DNS()
#{
#	if [ ! -d $(dirname "$DNS_FILE") ]; then
#		mkdir -p $(dirname "$DNS_FILE"
#}

# This allows connections to servers from any interface
INPUT()
{
	local IFACE="$1"
	local IP="$2"
	local PORT="$3"
	local PROTOCOL="$4"
	local IFS=' 	
'

	if [ ! -z "$5" ]; then
		local MAC="-m mac --mac-source $5"
	fi

	for interface in $IFACE; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ $IP == *':'* ]]; then
			local INPUT_IFACE=$(echo $IP | cut -d ":" -f1)
			local INPUT_IP=$(echo $IP | cut -d ":" -f2)
		else
			local INPUT_IFACE=$interface
			local INPUT_IP=$IP
		fi

		if [[ $interface =~ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} ]]; then
			local IFACE_IP=$interface
			local interface=$INPUT_IFACE
		else
			local IFACE_IP="$(ip address show $interface | grep -oP '(?<=inet ).*(?=/)')"
		fi

		if [[ $INPUT_IFACE == $interface ]]; then

			iptables -A INPUT -i $interface -p $PROTOCOL --dport $PORT -s $INPUT_IP -d $IFACE_IP $MAC -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
			iptables -A OUTPUT -o $interface -p $PROTOCOL --sport $PORT -d $INPUT_IP -s $IFACE_IP -m state --state ESTABLISHED,RELATED -j ACCEPT
		fi
	done
}

# This allows the router to connect to other servers from any interface
OUTPUT()
{
	local IFACE="$1"
	local IP="$2"
	local PORT="$3"
	local PROTOCOL="$4"
	local IFS=' 	
'

	if [ ! -z $5 ]; then
		local MAC="-m mac --mac-source $5"
	fi

	for interface in $IFACE; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ $IP == *':'* ]]; then
			local OUTPUT_IFACE=$(echo $IP | cut -d ":" -f1)
			local OUTPUT_IP=$(echo $IP | cut -d ":" -f2)
		else
			local OUTPUT_IFACE=$interface
			local OUTPUT_IP=$IP
		fi


		if [[ $interface =~ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} ]]; then
			local IFACE_IP=$interface
			local interface=$OUTPUT_IFACE
		else
			local IFACE_IP="$(ip address show $interface | grep -oP '(?<=inet ).*(?=/)')"
		fi


		if [[ $OUTPUT_IFACE == $interface ]]; then

			iptables -A INPUT -i $interface -p $PROTOCOL --sport $PORT -s $OUTPUT_IP -d $IFACE_IP $MAC -m state --state ESTABLISHED,RELATED -j ACCEPT
			iptables -A OUTPUT -o $interface -p $PROTOCOL --dport $PORT -d $OUTPUT_IP -s $IFACE_IP -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT

		fi
	done
}

# This allows lan clients to use the internet
FORWARD_NAT()
{
	local SRC_IFACE="$1"
	local SRC_IP="$2"
	local DST_IFACE="$3"
	local DST_IP="$4"
	local DST_PORT="$5"
	local PROTOCOL="$6"
	local IFS=' 	
'
	for interface in $SRC_IFACE; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ $SRC_IP == *':'* ]]; then
			local SRC_IFACE_1=$(echo $SRC_IP | cut -d ":" -f1)
			local SRC_IP_1=$(echo $SRC_IP | cut -d ":" -f2)
		else
			local SRC_IFACE_1=$interface
			local SRC_IP_1=$SRC_IP
		fi

		if [[ $SRC_IFACE_1 == $interface ]]; then
			iptables -A FORWARD -i $interface -p $PROTOCOL --dport $DST_PORT -s $SRC_IP_1 -d $DST_IP -j ACCEPT
			iptables -A FORWARD -i $DST_IFACE -p $PROTOCOL --sport $DST_PORT -d $SRC_IP_1 -s $DST_IP -j ACCEPT
			iptables -t nat -A POSTROUTING -o $DST_IFACE -j MASQUERADE
		fi
	done
}

# This allows which user and group can connect to what service
ACL_SERVICES()
{
	local IFACE="$1"
	local IP="$2"
	local PORT="$3"
	local USER_GROUP="$4"
	local PROTOCOL="$5"
	local IFS=' 	
'
	for interface in $IFACE; do
		# interface to ip 'tagging', useful for vlans and/or multiple interfaces
		if [[ $IP == *':'* ]]; then
			local ACL_IFACE=$(echo $IP | cut -d ':' -f1)
			local ACL_IP=$(echo $IP | cut -d ':' -f2)
		else
			local ACL_IFACE=$interface
			local ACL_IP=$IP
		fi

		if [[ $ACL_IFACE == $interface ]]; then

			if [[ $interface == *':'* ]]; then
				local interface=$(echo "$interface" | cut -d ':' -f1)
				local IFACE_IP=$(echo "$ACL_IFACE" | cut -d ':' -f2)
			else
				local IFACE_IP="$(ip address show $interface | grep -oP '(?<=inet ).*(?=/)' | cut -d " " -f1)"
			fi

			local USER=$(echo $USER_GROUP  | cut -zd ':' -f1 | sed 's/\x0//g')
			local GROUP=$(echo $USER_GROUP | cut -zd ':' -f2 | sed 's/\x0//g')

			if [ ! -z $USER ]; then
				local USER="-m owner --uid-owner $USER"
			fi

			if [ ! -z $GROUP ]; then
				local GROUP="-m owner --gid-owner $GROUP"
			fi

			iptables -A OUTPUT -o $interface -p $PROTOCOL --dport $PORT -s $IFACE_IP -d $ACL_IP $USER $GROUP -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
			iptables -A INPUT -i $interface -p $PROTOCOL --sport $PORT -d $IFACE_IP -s $ACL_IP -m state --state ESTABLISHED,RELATED -j ACCEPT
		fi
	done
}

### LO NOTES
### First a connection leaves // client:**** -> server:80			ACL_LO_CLIENT()
### Then a connection is received // server:80 <- client:****			ACL_LO_SERVER()
### Next server tries to connect back // server:80 -> client:****		ACL_LO_SERVER()
### Finally client establishes the connection // client:**** <- server:80	ACL_LO_CLIENT()


# For the time being, we need a special function for ACL'ing loopback
ACL_LO_CLIENT()
{
	local IP="$1"
	local PORT="$2"
	local USER_GROUP="$3"
	local PROTOCOL="$4"

	local USER=$(echo $USER_GROUP  | cut -zd ':' -f1 | sed 's/\x0//g')
	local GROUP=$(echo $USER_GROUP | cut -zd ':' -f2 | sed 's/\x0//g')

	if [ ! -z $USER ]; then
		local USER="-m owner --uid-owner $USER"
	fi

	if [ ! -z $GROUP ]; then
		local GROUP="-m owner --gid-owner $GROUP"
	fi

	iptables -A OUTPUT -o lo -p $PROTOCOL -s $IP -d $IP --dport $PORT $USER $GROUP -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT -i lo -p $PROTOCOL -d $IP -s $IP --sport $PORT -m state --state ESTABLISHED,RELATED -j ACCEPT
}

# A server function to prevent reduntant rules
ACL_LO_SERVER()
{

	local IP="$1"
	local PORT="$2"
	local USER_GROUP="$3"
	local PROTOCOL="$4"

	local USER=$(echo $USER_GROUP  | cut -zd ':' -f1 | sed 's/\x0//g')
	local GROUP=$(echo $USER_GROUP | cut -zd ':' -f2 | sed 's/\x0//g')

	if [ ! -z $USER ]; then
		local USER="-m owner --uid-owner $USER"
	fi

	if [ ! -z $GROUP ]; then
		local GROUP="-m owner --gid-owner $GROUP"
	fi

	iptables -A INPUT -i lo -p $PROTOCOL -d $IP -s $IP --dport $PORT -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	iptables -A OUTPUT -o lo -p $PROTOCOL -s $IP -d $IP --sport $PORT $USER $GROUP -m state --state ESTABLISHED,RELATED -j ACCEPT
}

ACL_LO()
{
	ACL_LO_CLIENT "$1" "$2" "$3" "$4"
	ACL_LO_SERVER "$1" "$2" "$3" "$4"
}

SAVE()
{
	# Sysvinit/systemd
	[[ $(which service 2>/dev/null) ]] && service iptables restart || \
	# openrc
	[[ $(which rc-service 2>/dev/null) ]] && rc-service iptables restart
}
